\chapter{Results and Conclusions}
%TODO


\section{Experimental Results}
%TODO

\section{Contribution}
The main parts of our technique were taken from the Java implementation of selective capture and replay from Joshi and Orso \cite{orso05may}, however there are some aspects that differ from their implementation and are to the best of our knowledge new:

\begin{itemize}
\item Our implementation of selective capture and replay targets Eiffel as a language.
\item We instrument applications in a way, so that the same executable can be used for both capture and replay phase. This makes it possible to replay an application immediately after it was captured, without recompiling it, which would take tens of minutes up to hours in Eiffel.
\item Our technique instruments code at the callee side, whereas Joshi and Orso instrument code at the caller side. 
\item Our instrumentation code determines whether an object is observed or unobserved dynamically, and we proposed a solution to do this check with only a small performance overhead. This enables equal instrumentation in all cases of inheritance, fully supporting dynamic binding. 
\end {itemize}

\section {Limitations}
Because of its limitations, the implementation that was made during this master thesis is to be seen as a proof of concept, only a small subset of programs can be captured and replayed. Here, we will provide a list of the known limitations:

\paragraph{Field Accesses}
The fact that there exists no automated code instrumentation for field accesses, limits the use of this implementation; however it has a weaker impact than it would have in Java, because in Eiffel, OUTREAD is the only type of field access that must be recorded in order to capture and replay an application. As a consequence of this limitation, only classes that don't read from unobserved fields can be put into the observed set.

\paragraph{Manifest Strings}
Manifest strings are directly initialized by the C code, that creates a string object and then directly writes the content of the manifest string into that object. Unlike the creation of the object, which is done using normal Eiffel routines, the initialization is directly done by the C code. This implies, that there is no instrumentation code invoked that could notice the change of the object's state. If an observed manifest string created in unobserved code and then passed to observed code, this leads to a fault during replay, because no event is generated and the initialization of the string can not be replayed. By inserting manual instrumentation using \texttt{\{SPECIAL\}.note\_direct\_manipulation}, it is possible to solve this issue. However this solution is not satisfying as manifest strings are used in many places and requiring the developer to insert manual instrumentation in each of these places is not realistic. A better solution would be to change the C macros that are used by the generated code to create manifest strings, in order to invoke the management code whenever a manifest string is instantiated.

\paragraph{Selective Exports}
In Eiffel a mechanism called \emph{selective exports} \cite{oosc2} lets classes decide, to which classes their features are exported. This feature can be seen as a generalization of Javas \emph{access level modifiers}. The problem arises whenever an observed class lets an unobserved class access a feature \identifier{f}, but prohibits the capture and replay management classes, especially class \texttt{CALLER}, from access to \identifier{f}. This leads to the situation where the event log contains an INCALL to the restricted feature, but \texttt{CALLER} is unable to call that feature during replay. A special case of selective exports are creation routines, that are often exported to \texttt{NONE} in order to restrict their usage exclusively to creation calls like \inlineeiffel{(create foo.creation\_procedure)}, which does not care about export restrictions.

The case of restricted creation procedures can be solved by treating them specially and only calling them in context of object creation. The reflection library generated by Erl-G already makes this distinction and can be used in order to replay them correctly. However, this only solves a part of the problem, all other cases of restricted access are not addressed by this solution. The only reasonable possibility to address all problems that come with selective exports, is a native reflection support in Eiffel with the option to ignore access restrictions. Native reflection support would improve the compile times of capture and replay enabled applications significantly, by not doubling the amount of classes and not making all classes part of the system. For a wider applicable implementation of selective capture and replay, native reflection support is indispensable.

\paragraph{Language Features}
At the moment only a subset of the Eiffel language features is supported. In the following we will present a list of missing features:

\begin{description}
 \item [Pre- and Postconditions] In Eiffel it is possible to add to every routine a pre- and a postcondition. The precondition, initiated by the \keyword{require} keyword, defines what the caller of the routine must ensure in order to safely call the routine. The postcondition, initiated by the \keyword{ensure} keyword, defines what the routine ensures after execution under the assumption that the precondition was met. The developer can activate the checking of these conditions, which results in a check of the precondition before and postcondition after every routine execution.\\
 Pre- and postcondition consist of a sequence of boolean Eiffel expressions, that contain function calls and attribute accesses. Thus when checking pre- and postconditions during application execution, additional events for selective capture and replay are triggered.\\
The technique must ensure that these function calls and attribute accesses do not take place during the replay phase if they are executed in the context of a unobserved routine, because it is required that unobserved code is not executed during replay phase. Furthermore it is desirable that these events are all triggered in the context of the routine the corresponding pre- and postcondition belongs to. This implies, that the instrumentation code for routine invocation must be executed before the precondition is checked and the instrumentation code for routine exit is executed after the last postcondition is checked. Otherwise the events triggered by the assertion code is executed in the context of the caller. At the moment selective capture and replay for Eiffel only works when checking of pre- and postconditions is disabled.

 \item [Class Invariants] In contrast to pre- and postcondition that express the properties of a routine, class invariants, which are initiated by the \keyword{invariant} keyword, express properties of a class. Like pre- and postconditions of routines, invariants are a sequence of boolean Eiffel expressions. They need to hold before and after all exported routines, an exception to that rule are creation procedures that establish the invariant, therefore the class invariant generally does not hold before the execution of a creation procedure.\\
The checking of the invariants can be enabled by the developer, according to the Eiffel ECMA standard \cite{Eiffel-ECMA}, they are then checked before and after every qualified routine call. As with pre- and postconditions of routines, this causes additional events during capture and replay phase, which is especially problematic for unobserved classes, which should not execute any code during replay phase. At the moment selective capture and replay for Eiffel only works with disabled invariant checking.

 \item [Exceptions] The original implementation of selective capture and replay creates an event whenever exceptions are thrown across the boundary. The current implementation for Eiffel ignores exceptions, which can cause an incorrect replay of the application, as exceptions have an impact on program flow. %Man koennte evtl. das default_rescue instrumentieren, um Exceptions einfach detektieren, allerdings muessten zusaetzlich auch alle rescue-clauses so instrumentiert werden, damit festgestellt werden kann, ob die routine eine Exception wirft --> keine einfache Sache!

 \item [Expanded Types] Variables of expanded type contain the object in contrast to regular variables that contain a reference to the object. Assigning a variable of expanded type to another variable (expanded or not) results in copying the object. Expanded types were not incorporated in the implementation of selective capture and replay for Eiffel. In general, integrating support for expanded types is no problem, but there is one thing that must be considered: it is not possible to change an expanded object in another scope than the one it is defined in, because it is not possible to reference an expanded object. Therefore it is not possible to change an expanded object originated from application code in the management code. This makes the proposed solution for OUTREAD events, modifying the target object from management code before it is accessed, inapplicable for expanded objects. One solution to this problem is to change a copy of the expanded object and assign that copy back to the original object.

 \item [Agents] Eiffel agents make it possible to wrap routines in objects. The current implementation of selective capture and replay for Eiffel has no support for agents.

 \item [Once Routines] Once routines are routines that use the \keyword{once} keyword instead of the \keyword{do} keyword. As the name suggests, once routines are executed once, at least in single threaded applications and if no special once key is defined (consult the Eiffel ECMA standard \cite{Eiffel-ECMA} for details). The current implementation does not instrument once routines, hence they are not supported. When adding support for once routines, unobserved once routines must be treated specially, because it is possible that the first call of the once routine does not come from observed code. The technique must store the result nonetheless, because it is possible that a later call will come from observed code. Therefore the first call to once function must initialize its result correctly, because any subsequent call will return the same result.
\end{description}

\paragraph{Object IDs}
In the current implementation, object IDs are not supported for instances of class \texttt{TUPLE}. This was discovered a while after they were developed and is caused by the irregular object layout that instances of class \texttt{TUPLE} have. It is possible that there are some more special cases left, although with \texttt{SPECIAL} and \texttt{TUPLE}, the usual suspects are treated.

When an object is copied using the feature \texttt{copy}, its object ID is copied, too. The correct behaviour in this case would be to request a new ID, because original and copy are two different objects and should therefore also have their own ID.

Another flaw regarding object IDs is that Eiffel's storable mechanism is not yet supported by the runtime with object ID support. Most probably this is also the reason, why Eiffel Studio using the modified runtime does not work properly.

\paragraph{Multi-Threading}
Selective capture and replay was not tested with a multi-threaded application, and some things were not designed with multi-threading in mind. One thing that certainly must be fixed in order to support multi-threading is the global counter for object IDs, which must be accessed using a mutex in order to avoid two objects, created by two threads, to have the same object ID.

When the whole management code is made thread safe, our implementation will still have the same limitation as the original one; it is required that multi-threading does not introduce any non determinism to the observed code.

\paragraph{Supported Compiler Backends}
At the moment, only frozen workbench code is supported, although most parts, like the automatically inserted instrumentation code also should work for other compiler backends, as they're implemented in pure Eiffel.


\section{Future Work}
The future work on selective capture and replay for Eiffel certainly has to focus on its current limitations. There are some limitations that restrict its usage to well prepared examples, for example the missing instrumentation of attribute accesses and the missing support for manifest strings. Making the current available features more robust is another area of work, for example the object ID support can be further improved so that they work under all circumstances. This requires additional example applications and test cases.

Native reflection support is crucial for the further success of selective capture and replay for Eiffel. The use of Erl-G is more to be seen as a workaround than a solution, because (a) there are some missing features, like access to selective exported features and (b) it raises the necessary compile time of a project enabled for selective capture and replay to hours, making it necessary to have a dedicated machine to compile the projects. No developer will accept this increase of compile time on project he is working on, therefore selective capture and replay for Eiffel is doomed in productive environments, as long as there is no native reflection support in Eiffel. But native reflection support is something that this project can not influence, this feature must be provided by the language maintainers.
