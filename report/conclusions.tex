\chapter{Results and Conclusions}
%TODO


\section{Experimental Results}
%TODO

\section{Contribution}
The main parts of our technique were taken from the Java implementation of selective capture and replay from Joshi and Orso \cite{orso05may}, however there are some aspects that differ from their implementation and were to the best of our knowledge never developed before.

Our implementation of selective capture and replay targets Eiffel as a language, which implied some changes to the way of instrumentation:
\begin{itemize}
\item We instrument applications in a way, so that the same executable can be used for both capture and replay phase. This makes it possible to replay an application immediately after it was captured, without recompiling it, which would take tens of minutes up to hours in Eiffel.
\item Our technique instruments code at the callee side, whereas Joshi and Orso instrument code at the caller side. 
\item Our instrumentation code determines whether an object observed or unobserved dynamically, and we proposed a solution to do this check with only a small performance penalty. This enables equal instrumentation in all cases of inheritance, fully supporting dynamic binding. 
\end {itemize}

\section {Limitations}
Because of its limitations, the implementation that was done during this master thesis is to be seen as a proof of concept, only a small subset of programs can be captured and replayed. Here, we will provide a list of the known limitations:

\paragraph{Field Accesses}
The fact that there exists no automated code instrumentation for field accesses, limits the use of this implementation; however it has a weaker impact than it would have in Java, because in Eiffel, OUTREAD is the only type of field access that has an impact on capture and replay. As a consequence of this limitation, only classes that don't read from unobserved fields can be put into the observed set.

\paragraph{Manifest Strings}
Manifest strings are directly initialized by the C code, which creates a string object and then directly writes the content of the manifest string into that object. Unlike the creation of the object, which is done using normal Eiffel routines, the initialization is directly done by the C code. This implies, that there is no instrumentation code invoked that could notice the change of the objects state. If an observed manifest string created in unobserved code and then passed to observed code, this leads to a fault during replay, because no event is generated and the initialization of the string can not be replayed. By inserting manual instrumentation using \texttt{\{SPECIAL\}.note\_direct\_manipulation}, it is possible to solve this issue. However this solution is not satisfying as manifest strings are used in many places and requiring the developer to insert manual instrumentation in each of these places is not realistic. A better solution would be to change the C macros that are used by the generated code to create manifest strings, in order to invoke the management code whenever a manifest string is instanciated.

\paragraph{Selective Exports}
In Eiffel a mechanism called \emph{selective exports} \cite{oosc2} lets classes decide, to which classes their features are exported. This feature can be seen as a generalization of Javas \emph{access level modifiers}. The problem arises whenever an observed class lets an unobserved class access a feature, but prohibits access to the capture and replay management classes, especially class \texttt{CALLER}. This leads to the situation where the event log contains an INCALL to the restricted feature, but \texttt{CALLER} is unable to call that feature during replay. A special case of selective exports are creation routines, that are often exported to \texttt{NONE} in order to restrict their usage exclusively to creation calls like \texttt{(create foo.creation\_procedure)}, which does not care about export restrictions.

The case of restricted creation procedures could be solved by treating them specially and only calling them in context of a object creation. The reflection library generated by Erl-G already makes this distinction and could be used in order to replay them correctly. However, this would only solve a part of the problem, all other cases of restricted access would not be adressed by this solution. The only reasonable possibility to address all problems that come with selective exports, would be a native reflection support in Eiffel with the option to ignore access restrictions. Native reflection support would improve the compile times of capture and replay enabled applications significantly, by not doubling the amount of classes and not making classes part of the system, too. For a wider applicable implementation of selective capture and replay, native reflection support is indispensable.

\paragraph{Language Features}
At the moment only a subset of the Eiffel language features is supported. In the following we will present a list of missing features:

\begin{description}
 \item [Pre- and Postconditions] In Eiffel it is possible to add to every routine a pre- and a postcondition. The precondition, initiated by the \keyword{require} keyword, defines what the caller of the routine must ensure in order to safely call the routine. The postcondition, initiated by the \keyword{ensure} keyword, defines what the routine ensures after execution under the assumption that the precondition was met when the routine was called. The developer can activate the checking of these conditions, which results in a check of the precondition before and postcondition after every routine.\\
 Pre- and postcondition consist of a sequence of boolean Eiffel expressions, that contain function calls and attribute accesses. Thus when checking pre- and postconditions during application execution, additional events for selective capture and replay are triggered. The technique must ensure that these function calls and attribute accesses do not take place during the replay phase if they are executed in the context of a unobserved routine because it is required that unobserved code is not executed during replay phase. Furthermore it is desirable that these events are all triggered in the context of the routine the corresponding pre- and postcondition belong to. This implies, that the instrumentation code for routine invocation is executed before the precondition is checked and the instrumentation code for routine exit is executed after the last postcondition is checked, otherwise the events triggered by the assertion code is executed in the context of the caller. At the moment selective capture and replay for Eiffel only works when checking of pre- and postconditions is disabled.
 \item [Class Invariants] In contrast to pre- and postcondition that express the properties of a routine, class invariants, which are iniated by the \keyword{invariant} keyword, express properties of a class. Like pre- and postconditions of routines, invariants are a sequence of boolean Eiffel expressions that need to hold before and after all exportd routines. An exception to that rule are creation procedures that establish the invariant, therefore the class invariant usually does not hold before the execution of a creation procedure.\\
The checking of the invariants can be enabled by the developer, according to the Eiffel ECMA standard \cite{Eiffel-ECMA}, they are then checked before and after every qualified routine call. As with pre- and postconditions of routines, this causes additional events during capture and replay phase, which is especially problematic for unobserved classes, which should not execute any code during replay phase. At the moment selective capture and replay for Eiffel only works with disabled invariant checking.
 \item [Exceptions] The original implementation of selective capture and replay creates an event whenever Exceptions are thrown accross the boundary. The current implementation for Eiffel ignores exceptions, which could cause an incorrect replay of the application, as exceptions have an impact on program flow. %Man koennte evtl. das default_rescue instrumentieren, um Exceptions einfach detektieren, allerdings muessten zusaetzlich auch alle rescue-clauses so instrumentiert werden, damit festgestellt werden kann, ob die routine eine Exception wirft --> keine einfache Sache!
 \item [Expanded Types] In Eiffel variables of expanded type contain the object in contrast to regular variables that contain a reference to the object. Assigning a variable of expanded type to another variable (expanded or not) results in copying the object. Expanded types were not incorporated in the implementation of selective capture and replay for Eiffel. In general, it should not be a problem to integrate support for expanded types into the implementation, but there is one thing that must be considered: it is not possible to change an expanded object in another scope than the one it is defined in. The reason is that it is not possible to reference an expanded object, thus it is not possible to change an expanded object from application code in the management code. This makes the proposed solution for OUTREAD events, modifying the target object from management code before it is accessed, unapplicable for expanded objects. A solution to this problem is to change a copy of the expanded object and assign that copy back to the original object.
 \item [Agents] Eiffel agents make it possible to wrap routines in objects. The current implementation of selective capture and replay for Eiffel has no support for agents.
 \item [Once Routines] Once routines are routines that use the \keyword{once} keyword instead of the \keyword{do} keyword. As the name suggests, once routines are executed once, at least in single threaded applications and if no once key is defined (consult the Eiffel ECMA standard \cite{Eiffel-ECMA} for details). Because during ther first (and only) execution, once routines have the same semantics as normal routines, it suffices to instrument them in the same way as normal routines. Any subsequent call to a once routine has the same outcome, be it the same result or the same exception. If the once routine is instrumented in the same way as a normal routine, we can guarantee, that the result of the first execution is the same as during capture phase, therefore all subsequent calls produce the same result as during capture phase. At the moment, selective capture and replay for Eiffel does not instrument once routines and therefore does not support them.
\end{description}

\paragraph{Object IDs}
In the current implementation, object IDs are not supported for instances of class \texttt{TUPLE}. This was discovered a while after they were developed and is caused by the irregular object layout that instances of class \texttt{TUPLE} have. It is possible that there are some more special cases left, although with \texttt{SPECIAL} and \texttt{TUPLE}, the usual suspects are treated with.

When an object is copied using the feature \texttt{copy}, its object ID is copied, too. The correct behaviour in this case would be to request a new ID, because original and copy are two different objects and should therefore also have their own ID.

Another flaw regarding object IDs is that Eiffels storable mechanism is not yet supported by a runtime that has object ID support. Most probably this is also the reason, why it is not yet possible to run an instance of Eiffel Studio that was compiled using the modified runtime.

\paragraph{Multi Threading}
Selective capture and replay was not tested with a multi threaded application, and some things were not designed with multi threading in mind. One thing that certainly must be fixed in order to support multi threading is the global counter for object IDs, which must be accessed using a mutex in order to avoid two objects, created by two threads, to have the same object ID.

When the whole management code is made thread safe, our implementation will still have the same limitation as the original one; it is required that multi threading does not introduce any non determinism to the observed code.

\paragraph{Supported Compiler Backends}
At the moment, only frozen workbench code is supported, although most parts, like the automatically inserted instrumentation code also should work for other compiler backends, as they're implemented in pure Eiffel.
\section{Future Work}
%Limitations beheben:
-Object IDs komplett instrumentieren und rock stable machen
- Field Accesses instrumentieren
- Lösung für manifest strings

Native Reflection support von Eiffel, alles andere bringt nichts.
Missing 
--

%Fehlende features + idee zu deren implementierung


