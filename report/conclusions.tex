\chapter{Results and Conclusions}

\section{Experimental Results}


\section{Contribution}
The main parts of our technique were taken from the Java implementation of selective capture and replay from Joshi and Orso \cite{orso05may}, however there are some aspects that differ from their implementation and were to the best of our knowledge never implemented before.

Our implementation of selective capture and replay targets Eiffel as a language, which implied some changes to the way of instrumentation:
\begin{itemize}
\item We instrument applications in a way, so that the same executable can be used for both capture and replay phase. This makes it possible to replay an application immediately after it was captured, without recompiling it, which would take tens of minutes up to hours in Eiffel.
\item Our technique instruments code at the callee side, whereas Joshi and Orso instrument code at the caller side. 
\item Our instrumentation code determines whether an object observed or unobserved dynamically, and we proposed a solution to do this check with only a small performance penalty. This enables equal instrumentation in all cases of inheritance, fully supporting dynamic binding. 
\end {itemize}

\section {Limitations}
Because of its limitations, the implementation that was done during this master thesis is to be seen as a proof of concept, only a small subset of programs can be captured and replayed. Here, we will provied a list of the known limitations:

\paragraph{Field Accesses}
The fact that there exists no automated code instrumentation for field accesses, limits the use of this implementation; however it has a weaker impact than it would have in Java, because in Eiffel, OUTREAD is the only type of field access that has an impact on capture and replay. As a consequence of this limitation, only classes that don't read from unobserved fields can be put into the observed set.

\paragraph{Manifest Strings}
Manifest strings are directly initialized by the C code, which creates a string object and then directly writes the content of the manifest string into that object. Unlike the creation of the object, which is done using normal Eiffel routines, the initialization is directly done by the C code. This implies, that there is no instrumentation code invoked that could notice the change of the objects state. If an observed manifest string created in unobserved code and then passed to observed code, this leads to a fault during replay, because no event is generated and the initialization of the string can not be replayed. By inserting manual instrumentation using \texttt{\{SPECIAL\}.note\_direct\_manipulation}, it is possible to solve this issue. However this solution is not satisfying as manifest strings are used in many places and requiring the developer to insert manual instrumentation in each of these places is not realistic. A better solution would be to change the C macros that are used by the generated code to create manifest strings, in order to invoke the management code whenever a manifest string is instanciated.

\paragraph{Selective Exports}
In Eiffel a mechanism called \emph{selective exports} \cite{oosc2} lets classes decide, to which classes their features are exported. This feature can be seen as a generalization of Javas \emph{access level modifiers}. The problem arises whenever an observed class lets an unobserved class access a feature, but prohibits access to the capture and replay management classes, especially class \texttt{CALLER}. This leads to the situation where the event log contains an INCALL to the restricted feature, but \texttt{CALLER} is unable to call that feature during replay. A special case of selective exports are creation routines, that are often exported to \texttt{NONE} in order to restrict their usage exclusively to creation calls like \texttt{(create foo.creation\_procedure)}, which does not care about export restrictions.

The case of restricted creation procedures could be solved by treating them specially and only calling them in context of a object creation. The reflection library generated by Erl-G already makes this distinction and could be used in order to replay them correctly. However, this would only solve a part of the problem, all other cases of restricted access would not be adressed by this solution. The only reasonable possibility to address all problems that come with selective exports, would be a native reflection support in Eiffel with the option to ignore access restrictions. Native reflection support would improve the compile times of capture and replay enabled applications significantly, by not doubling the amount of classes and not making classes part of the system, too. For a wider applicable implementation of selective capture and replay, native reflection support is indispensable.

\paragraph{Missing Language Features}



\paragraph{Object IDs}
In the current implementation, object IDs are not supported for instances of class \texttt{TUPLE}. This was discovered a while after they were implemented and is caused by the irregular object layout that instances of class \texttt{TUPLE} have. It is possible that there are some more special cases left, although with \texttt{SPECIAL} and \texttt{TUPLE}, the usual suspects are treated with.

When an object is copied using the feature \texttt{copy}, its object ID is copied, too. The correct behaviour in this case would be to request a new ID, because original and copy are two different objects and should therefore also have their own ID.

Another flaw regarding object IDs is that Eiffels storable mechanism is not yet supported by a runtime that has object ID support. Most probably this is also the reason, why it is not yet possible to run an instance of Eiffel Studio that was compiled using the modified runtime.

\paragraph{Multi Threading}
Selective capture and replay was not tested with a multi threaded application, and some things were not designed with multi threading in mind. One thing that certainly must be fixed in order to support multi threading is the global counter for object IDs, which must be accessed using a mutex in order to avoid two objects, created by two threads, to have the same object ID.

When the whole management code is made thread safe, our implementation will still have the same limitation as the original one; it is required that multi threading does not introduce any non determinism to the observed code.
%Manifest strings, die von unobserved code erstellt werden und danach observed code überreicht werden, werden nicht richtig replayed. -->manuelle instrumentierung (im Moment)

\paragraph{Supported Compiler Backends}
At the moment, only frozen workbench code is supported, although most parts, like the automatically inserted instrumentation code also should work for other compiler backends, as they're implemented in pure Eiffel.
\section{Future Work}
%Limitations beheben:
-Object IDs komplett instrumentieren und rock stable machen
- Field Accesses instrumentieren
- Lösung für manifest strings

Native Reflection support von Eiffel, alles andere bringt nichts.

--

%Fehlende features + idee zu deren implementierung


