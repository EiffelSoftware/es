\chapter{Introduction}
%The initial part of the introduction was taken from the abstract. Maybe some modifications are to be done here...
Debugging applications is very tedious work. One of the hardest steps to find a fault in a program is to reproduce the steps that lead to the associated program failure. Capture and replay aims at simplifying this process. In order to be able to replay an application, it is necessary to isolate the deterministic part of the application that needs to be replayed (observed part) and the non-deterministic parts, like user input, storage or network (unobserved part). Once the behavior of the unobserved part can be captured and replayed, it is also possible to replay the observed part. Although capture and replay is commonly known as capturing mouse and keyboard events, there are approaches that go further and capture events from all interactions with the environment. All these approaches have one thing in common: They have a fixed border between observed and unobserved part.

Selective Capture and Replay \cite{orso05may} makes it possible to individually define the observed part, thus it offers the possibility to optimize the amount of information that needs to be captured. To reduce the amount of captured data, Selective Capture and Replay uses another amazingly simple technique: Whenever an object passes the border, only its type and a unique identifier is recorded, unless the passed object is from a basic type. This is sufficient to allow a complete replay, because the notion of observed and unobserved part is extended from code to objects. If an observed object was passed, the object will be correctly rebuilt during replay, thus it is not necessary to store any additional information. If the passed object is not observed, it is only a stub anyway and all accesses to it will result in events that can be replayed. Therefore the recorded data will be linear to the number of variables passed through the border, in contrast to other techniques which capture the whole data that is passed.

These advantages make Selective Capture and Replay an interesting approach to implement capture and replay for Eiffel. It would allow capture and replay functionality for whole applications with some changes in the runtime and modifications in the libraries that are significantly smaller than traditional approaches.

The original implementation for Selective Capture and Replay was made for Java. The technique proposed in the original paper can not be completely applied to Eiffel because some language features differ between Eiffel and Java. Some of these differences make an implementation easier (e.g. it is not possible to change attributes of other classes) and some make it harder (e.g. multiple inheritance). Selective Capture and Replay heavily relies on code instrumentation to capture accesses across the border. The original implementation instruments method and attribute accesses on the caller (client) side, which is not possible for Eiffel: Due to multiple inheritance, it cannot be determined whether the callee (server) is observed or not. Therefore we instrument code at the callee side. Another modification that was made to the instrumentation allows switching between capture and replay without recompilation. Although this feature costs in terms of performance, it is necessary for Eiffel, because reinstrumenting the code would require a complete recompile. The original implementation allows faster instrumentation, as it instruments at the bytecode level and therefore doesn't need a complete recompile when the code should be instrumented differently.

When speaking about performance, it is important to note that the current implementation was not optimized for speed. It was more important to provide a running implementation that shows whether Selective Capture and Replay is applicable for Eiffel. Nonetheless, some performance measurements will be presented, based on a simple example application.


