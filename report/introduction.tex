\chapter{Introduction}
%The initial part of the introduction was taken from the abstract. Maybe some modifications are to be done here...
Debugging applications is very tedious work. One of the hardest steps to find a fault in a program is to reproduce the steps that lead to the associated program failure. Capture and replay aims at making the run of a program repeatable, removing this burden from the developer. In order to be able to replay an application, it is necessary to isolate the deterministic part of the application that needs to be replayed (observed part) and the non-deterministic parts, like user input, storage or network (unobserved part). Once the behavior of the unobserved part can be captured and replayed, it is also possible to replay the observed part. Although capture and replay is commonly known as capturing mouse and keyboard events, there are approaches that go further and capture events from all interactions with the environment. All these approaches have one thing in common: They have a fixed border between observed and unobserved part.

Selective Capture and Replay \cite{orso05may} makes it possible to individually define the observed part. Because the information flow is not equally intense between all parts of a program, this offers the possibility to optimize the amount of information that needs to be captured. To reduce the amount of captured data, Selective Capture and Replay uses another amazingly simple technique: Whenever an object passes the border, only its type and a unique identifier is recorded, unless the passed object is from a basic type. %This is sufficient to allow a complete replay, because the notion of observed and unobserved part is extended from code to objects. If an observed object was passed, the object will be correctly rebuilt during replay, thus it is not necessary to store any additional information. If the passed object is not observed, it is only a stub anyway and all accesses to it will result in events that can be replayed. Therefore the recorded data will be linear to the number of variables passed through the border, in contrast to other techniques which capture the whole data that is passed.
%Alternative Version:
It can be shown that given some assumptions, this suffices to replay the observed part. Using this technique, it is possible to ensure that the recorded data will be linear to the number of variables passed through the border, in contrast to other techniques which capture the whole data that is passed

We have implemented a selective capture and replay framework for Eiffel. It allows capture and replay functionality for whole applications with some changes in the runtime and modifications in the libraries that are significantly smaller than for traditional approaches.

The original implementation for selective capture and replay was made for Java. The technique proposed in the original paper can not be completely applied to Eiffel because some language features differ between Eiffel and Java. Some of these differences make an implementation easier (e.g. it is not possible to change attributes of other classes) and some make it harder (e.g. contracts). Selective capture and replay heavily relies on code instrumentation to capture accesses across the border. The original implementation instruments method and attribute accesses on the caller (client) side, whereas we instrument code at the callee side. %TODO abschliessender Satz. Macht es das wirklich sicherer bei polymorphismus? (a.call --> if a.is_observed then a.call...;
The instrumentation our modified compilers makes to the program is the same for both the capture and the replay run. Hence no recompilation between the two phases is necessary. Depending on the program, compilation times can last for tens of minutes up to hours. For some capture and replay applications a recompilation can be prohibitive, therefore this feature is necessary although it costs in terms of performance. The original implementation instruments the program at the bytecode level and consequently doesn't need a complete recompile when the code should be instrumented differently.

The current implementation was not optimized for speed, because it was more important to provide a running implementation that shows whether Selective Capture and Replay is applicable to Eiffel or not. Nonetheless, some performance measurements will be presented, based on a simple example application.


